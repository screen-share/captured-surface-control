<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <title>Captured Surface Control</title>
    <script class="remove" src="captured-surface-control.js" type="text/javascript"></script>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
    <link href="style.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <section id="abstract">
      <p>
        Consider a Web application |capturer| which has used {{MediaDevices/getDisplayMedia()}} to
        start capturing another [=display surface=] we call |capturee|. This specification
        introduces a set of APIs that allow |capturer| the following new capabilities:
      </p>
      <ul>
        <li>Read and write |capturee|'s [=zoom level=].</li>
        <li>
          Deliver a wheel event over |capturee|'s viewport at coordinates of |capturer|'s choosing.
        </li>
      </ul>
      <p>
        Initially, these are only specified for captured [=display surfaces=] of type [=display
        surface/browser=], but an extension to [=display surface/window=] is considered.
      </p>
    </section>

    <section id="sotd"></section>

    <section id="background">
      <h1>Background</h1>
      <p>
        Nearly all video-conferencing Web applications offer their users the ability to share
        [=display surfaces=] - typically a browser tab ([=display surface/browser=]), a native app's
        window ([=display surface/window=]), or an entire screen ([=display surface/monitor=]).
      </p>
      <p>
        Many of these applications also show the local user a "preview tile" with a video of the
        captured [=display surface=].
      </p>
      <p>
        All these applications suffer from one key drawback - if the user wishes to interact with a
        captured [=display surface=], the user must first switch to that surface, taking them away
        from the video-conferencing application. This presents a few issues:
      </p>
      <ol>
        <li>
          Users can't simultaneously interact with the captured application and see the videos of
          remote users.
        </li>
        <li>
          Users are burdened by the need to repeatedly switch between the video-conferencing
          application and the captured surface.
        </li>
        <li>
          Users are limited in their ability to see and interact with controls exposed by the
          video-conferencing application while they are interacting with the captured surface. A
          non-comprehensive list of examples of such controls includes - embedded chat applications,
          emoji reactions, "knock-ins" by users asking to join the call, and multimedia controls.
        </li>
        <!-- TODO: Reintroduce the following in a separate section focusing on potential future scope:
        <li>
          Local users who are presenting cannot delegate some limited control to remote
          participants. This leads to the all too familiar scenario, where remote users must beg the
          local user to change the slide or scroll a bit up/down.
        </li> -->
      </ol>
      <p>
        It bears mentioning that
        <a href="https://wicg.github.io/document-picture-in-picture/"
          >Document Picture-in-Picture</a
        >
        goes a long way towards addressing some of these issues. However, it not always a suitable
        solution, as not all use cases are adequately addressed by a floating window which will
        often be small, which obscures arbitrary other content on the screen, and whose size and
        positioning must be manually controlled by the user.
      </p>
    </section>

    <section id="feature-policy-integration">
      <h1>Permissions Policy Integration</h1>
      <p>
        This specification defines a [=policy-controlled feature=] identified by the string
        <dfn class="permission export"><code>"captured-surface-control"</code></dfn
        >. Its [=policy-controlled feature/default allowlist=] is <code>"self"</code>.
      </p>
      <div class="note">
        <p>
          The API surfaces introduced by this specification can be categorized as either read-access
          or write-access. Note that only the write-access APIs ({{CaptureController/setZoomLevel}}
          and {{CaptureController/captureWheel}}) are gated by the <a>"captured-surface-control"</a>
          permissions policy.
        </p>
      </div>
    </section>

    <section id="zoom">
      <h1>Zoom</h1>
      <section id="zoom-definition">
        <h2>Definition of Zoom</h2>
        <p>
          We define a concept of an integer "<dfn>zoom level</dfn>" that can be applied to [=display
          surfaces=] of any type, and which is independent of the user agent and the platform. It is
          expected that in the case of [=display surface/browser=] [=display surfaces=], this
          concept will match the concept of zoom level that user agents typically exposed to the
          user.
        </p>
        <ul>
          <li>
            The <dfn>default zoom level</dfn> of any [=display surface=] is defined to be 100. All
            implementations must support this value for all [=display surface=] of any type.
          </li>
          <li>
            Decreasing [=zoom level=] values represent "zooming out". The minimum theoretical value
            is 1; however, user agents may cap their support for "zooming out" at a larger values,
            with 100 being the largest permissible minimum value, representing lack of support for
            "zooming out".
          </li>
          <li>
            Increasing values represent "zooming in". This specification does not mandate a
            theoretical maximum. The smallest possible maximum is 100, which represents lack of
            support for "zooming in".
          </li>
        </ul>
        <p>
          For a given [=display surface=] of type |surfaceType|, we define the user agent's set of
          <dfn>supported zoom levels</dfn> for |surfaceType| as a non-empty set of integers
          including at least the [=default zoom level=] (100), and not including any integers lesser
          than 1.
        </p>
      </section>
      <section id="zoom-control-apis">
        <h2>Zoom-control APIs</h2>
        <pre class="idl">
          partial interface CaptureController {
            sequence&lt;long&gt; getSupportedZoomLevels();
            long getZoomLevel();
            Promise&lt;undefined&gt; setZoomLevel(long zoomLevel);
            attribute EventHandler oncapturedzoomlevelchange;
          };
        </pre>
        <dl data-link-for="CaptureController" data-dfn-for="CaptureController" class="methods">
          <dt><dfn>getSupportedZoomLevels()</dfn></dt>
          <dd>
            <p>
              This method allows applications to discover the set of [=zoom levels=] supported by
              the user agent.
            </p>
            <p>When invoked, the user agent MUST run the following steps:</p>
            <ol>
              <li>
                If [=this=] is not [=actively capturing=], [=exception/throw=] an
                "{{InvalidStateError}}" {{DOMException}}.
              </li>
              <li>
                Let |surfaceType| be [=this=].<a data-cite="!screen-capture/#dfn-displaysurfacetype"
                  >[[\DisplaySurfaceType]]</a
                >.
              </li>
              <li>
                If |surfaceType| is not a [=supported display surface type=], [=exception/throw=] a
                "{{NotSupportedError}}" {{DOMException}}.
              </li>
              <li>
                Return a monotonically increasing sequence containing all of the values in the
                [=supported zoom levels=] for |surfaceType|.
              </li>
            </ol>
          </dd>
          <dt><dfn>getZoomLevel()</dfn></dt>
          <dd>
            <p>
              This method allows applications to discover the captured [=display surface=]'s [=zoom
              level=].
            </p>
            <p>When invoked, the user agent MUST run the following steps:</p>
            <ol>
              <li>
                If [=this=] is not [=actively capturing=], [=exception/throw=] an
                "{{InvalidStateError}}" {{DOMException}}.
              </li>
              <li>
                If [=this=].<a data-cite="!screen-capture/#dfn-displaysurfacetype"
                  >[[\DisplaySurfaceType]]</a
                >
                is not a [=supported display surface type=], [=exception/throw=] a
                "{{NotSupportedError}}" {{DOMException}}.
              </li>
              <li>
                Return [=this=].<a data-cite="!screen-capture/#dfn-source">[[\Source]]</a>'s [=zoom
                level=].
              </li>
            </ol>
          </dd>
          <dt><dfn>setZoomLevel()</dfn></dt>
          <dd>
            <p>
              This method allows applications to set the captured [=display surface=]'s [=zoom
              level=].
            </p>
            <p>When invoked, the user agent MUST run the following steps:</p>
            <ol>
              <li>
                Let |document:Document| be the [=relevant global object=]'s [=associated
                `Document`=].
              </li>
              <li>
                If [=this=] is not [=actively capturing=], return a promise [=reject|rejected=] with
                a {{DOMException}} object whose {{DOMException/name}} attribute has the value
                {{InvalidStateError}}.
              </li>
              <li>
                Let |surfaceType| be [=this=].<a data-cite="!screen-capture/#dfn-displaysurfacetype"
                  >[[\DisplaySurfaceType]]</a
                >.
              </li>
              <li>
                If |surfaceType| is not a [=supported display surface type=], return a promise
                [=reject|rejected=] with a {{DOMException}} object whose {{DOMException/name}}
                attribute has the value {{NotSupportedError}}.
              </li>
              <li>Let |targetZoomLevel| be the method's first argument.</li>
              <li>
                If |targetZoomLevel| is not included in the user agent's set of [=supported zoom
                levels=] for |surfaceType|, return a promise [=reject|rejected=] with a
                {{DOMException}} object whose {{DOMException/name}} attribute has the value
                {{InvalidStateError}}.
              </li>
              <li>Let |P| be a new {{Promise}}.</li>
              <li>
                <p>Run the following steps [=in parallel=]:</p>
                <ol>
                  <li>
                    [=Request permission to use=] a {{PermissionDescriptor}} with its
                    {{PermissionDescriptor/name}} member set to
                    <a>"captured-surface-control"</a>. If the result of the request is
                    {{PermissionState/"denied"}}, [=reject=] |P| with a new {{DOMException}} object
                    whose {{DOMException/name}} is {{NotAllowedError}} and abort these steps.
                  </li>
                  <li>
                    Set [=this=].<a data-cite="!screen-capture/#dfn-source">[[\Source]]</a>'s [=zoom
                    level=] to |targetZoomLevel|.
                  </li>
                  <li>[=Resolve=] |P|.</li>
                </ol>
              </li>
              <li>Return |P|.</li>
            </ol>
          </dd>
          <dt><dfn>oncapturedzoomlevelchange</dfn></dt>
          <dd>
            <p>
              The user agent MUST fire a blank event on this {{EventHandler}} whenever [=this=].<a
                data-cite="!screen-capture/#dfn-source"
                >[[\Source]]</a
              >'s [=zoom level=] changes.
            </p>
            <div class="note">
              <p>Examples of causes include:</p>
              <ul>
                <li>
                  The user interacted with the user agent to change the zoom level of a captured
                  tab.
                </li>
                <li>The capturing application called {{CaptureController/setZoomLevel()}}.</li>
                <li>
                  The user changed the shared [=display surface=], choosing one which has a
                  different [=zoom level=].
                </li>
              </ul>
            </div>
          </dd>
        </dl>
      </section>
    </section>

    <section id="scrolling">
      <h1>Scroll</h1>
      <h2>Scrolling APIs</h2>
      <pre class="idl">
        partial interface CaptureController {
          constructor();
          Promise&lt;undefined&gt; captureWheel(HTMLElement element);
        };
      </pre>
      <dl data-link-for="CaptureController" data-dfn-for="CaptureController" class="methods">
        <dt><dfn>constructor</dfn></dt>
        <dd>
          <p>
            {{CaptureController}}'s
            <a data-cite="!screen-capture/#dom-capturecontroller-constructor">constructor</a> is
            extended to also define and initialize the following internal slots:
          </p>
          <table class="simple">
            <thead>
              <tr>
                <th>Internal Slot</th>
                <th>Initial value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><dfn>[[\CaptureWheelElement]]</dfn></td>
                <td><code>null</code></td>
              </tr>
              <tr>
                <td><dfn>[[\CaptureWheelEventListener]]</dfn></td>
                <td><code>null</code></td>
              </tr>
            </tbody>
          </table>
        </dd>
        <dt><dfn>captureWheel()</dfn></dt>
        <dd>
          <p>
            This method allows applications to automatically forward
            <a href="https://w3c.github.io/uievents/#idl-wheelevent">wheel events</a>
            from an {{HTMLElement}} to the viewport of a captured [=display surface=].
          </p>
          <p>When invoked, the user agent MUST run the following steps:</p>
          <ol>
            <li>
              If [=this=] is not [=actively capturing=], return a promise [=reject|rejected=] with a
              {{DOMException}} object whose {{DOMException/name}} attribute has the value
              {{InvalidStateError}}.
            </li>
            <li>
              Let |surfaceType| be [=this=].<a data-cite="!screen-capture/#dfn-displaysurfacetype"
                >[[\DisplaySurfaceType]]</a
              >.
            </li>
            <li>
              If |surfaceType| is not a [=supported display surface type=], return a promise
              [=reject|rejected=] with a {{DOMException}} object whose {{DOMException/name}}
              attribute has the value {{NotSupportedError}}.
            </li>
            <li>Let |element| be the method's first argument.</li>
            <li>Let |P| be a new {{Promise}}.</li>
            <li>
              Run the following steps [=in parallel=]:
              <ol>
                <li>
                  [=Get the current permission state=] of <a>"captured-surface-control"</a>. If the
                  result is NOT {{PermissionState/"granted"}}, and the [=relevant global object=]
                  does NOT have [=transient activation=], return a promise [=reject|rejected=] with
                  a {{DOMException}} object whose {{DOMException/name}} attribute has the value
                  {{InvalidStateError}}.
                  <div class="note">
                    <p>
                      This step ensures that on the one hand, permission prompts are not be shown
                      without [=transient activation=], while on the one hand, if the permission is
                      already {{PermissionState/"granted"}}, {{CaptureController/captureWheel()}}
                      may be called immediately after {{MediaDevices/getDisplayMedia()}} resolves,
                      even if the [=transient activation=] that permitted the call to
                      {{CaptureController/captureWheel()}} has since expired.
                    </p>
                  </div>
                </li>
                <li>
                  [=Request permission to use=] a {{PermissionDescriptor}} with its
                  {{PermissionDescriptor/name}} member set to
                  <a>"captured-surface-control"</a>. If the result of the request is
                  {{PermissionState/"denied"}}, [=reject=] |P| with a new {{DOMException}} object
                  whose {{DOMException/name}} is {{NotAllowedError}} and abort these steps.
                </li>
                <li>
                  <p>
                    If [=this=].{{CaptureController/[[CaptureWheelElement]]}} is not
                    <code>null</code>, [=remove an event listener=] with:
                  </p>
                  <ul>
                    <li>
                      [=this=].{{CaptureController/[[CaptureWheelElement]]}} as |eventTarget|.
                    </li>
                    <li>
                      [=this=].{{CaptureController/[[CaptureWheelEventListener]]}} as |listener|.
                    </li>
                  </ul>
                </li>
                <li>Set [=this=].{{CaptureController/[[CaptureWheelElement]]}} to |element|.</li>
                <li>
                  Set [=this=].{{CaptureController/[[CaptureWheelEventListener]]}} to
                  <code>null</code>.
                </li>
                <li>
                  If [=this=].{{CaptureController/[[CaptureWheelElement]]}} is <code>null</code>,
                  [=resolve=] |P| and abort these steps.
                </li>
                <li>
                  Set [=this=].{{CaptureController/[[CaptureWheelEventListener]]}} to an [=event
                  listener=] defined as follows:
                  <dl>
                    <dt>type</dt>
                    <dd><code>wheel</code></dd>
                    <dt>[=event listener/callback=]</dt>
                    <dd>
                      The result of creating a new Web IDL {{EventListener}} instance representing a
                      reference to a function of one argument of type {{Event}} |event|. This
                      function executes the [=forward wheel event algorithm=] given [=this=] and
                      |event|.
                    </dd>
                  </dl>
                </li>
                <li>
                  <p>[=Add an event listener=] with:</p>
                  <ul>
                    <li>
                      [=this=].{{CaptureController/[[CaptureWheelElement]]}} as |eventTarget|.
                    </li>
                    <li>
                      [=this=].{{CaptureController/[[CaptureWheelEventListener]]}} as |listener|.
                    </li>
                  </ul>
                </li>
                <li>[=Resolve=] |P|.</li>
              </ol>
            </li>
            <li>Return |P|.</li>
          </ol>
        </dd>
      </dl>
    </section>

    <section>
      <h1>Subroutines</h1>
      <section>
        <h2>Subroutine: Actively capturing</h2>
        <p>
          To determine if a {{CaptureController}} |controller| is
          <dfn>actively capturing</dfn>, run the following steps:
        </p>
        <ol>
          <li>
            <!-- TODO: Fix the export of CaptureController's internal slots and use them. -->
            Let |source| be |controller|.<a data-cite="!screen-capture/#dfn-source">[[\Source]]</a>.
          </li>
          <li>If |source| is <code>null</code>, return <code>false</code>.</li>
          <li>
            If |source| has been <a data-cite="GETUSERMEDIA#source-stopped">stopped</a>, return
            <code>false</code>.
          </li>
          <li>Return <code>true</code>.</li>
        </ol>
      </section>
      <section>
        <h2>Subroutine: Supported display surface type</h2>
        <p>
          To determine if a [=display surface=] |surfaceType| is
          <dfn>supported display surface type</dfn>, run the following steps:
        </p>
        <ol>
          <li>If |surfaceType| is [=display surface/browser=], return <code>true</code>.</li>
          <li>Return <code>false</code>.</li>
        </ol>
        <div class="note">
          <p>Whether [=display surface/window=] should be supported is under discussion.</p>
        </div>
      </section>
      <section>
        <h2>Subroutine: Forward wheel event</h2>
        <p>
          The <dfn>forward wheel event algorithm</dfn> takes a {{CaptureController}} |controller|
          and a {{WheelEvent}} |event|, and runs the following steps:
        </p>
        <ol>
          <li>If |controller| is not [=actively capturing=], abort these steps.</li>
          <li>
            Let |surfaceType| be |controller|.<a data-cite="!screen-capture/#dfn-displaysurfacetype"
              >[[\DisplaySurfaceType]]</a
            >.
          </li>
          <li>If |surfaceType| is not a [=supported display surface type=], abort these steps.</li>
          <li>
            Run the following steps [=in parallel=]:
            <ol>
              <li>
                [=Get the current permission state=] of <a>"captured-surface-control"</a>. If the
                result is NOT {{PermissionState/"granted"}}, abort these steps.
              </li>
              <li>If |event|.{{Event/isTrusted}} is <code>false</code>, abort these steps.</li>
              <li>
                Let [|scaledX|, |scaledY|] be the result of the [=scale element coordinates
                algorithm=] on [|event|.{{MouseEvent/offsetX}}, |event|.{{MouseEvent/offsetY}}] and
                [=this=].{{CaptureController/[[CaptureWheelElement]]}}.
              </li>
              <li>
                [=Fire an event=] named `"wheel"` using {{WheelEvent}} with the {{MouseEvent/x}}
                attribute initialized to |scaledX|, the {{MouseEvent/y}} attribute initialized to
                |scaledY|, the {{WheelEvent/deltaX}} attribute initialized to
                |event|.{{WheelEvent/deltaX}} and the {{WheelEvent/deltaY}} attribute initialized to
                |event|.{{WheelEvent/deltaY}}, at |controller|.<a
                  data-cite="!screen-capture/#dfn-source"
                  >[[\Source]]</a
                >'s viewport.
              </li>
            </ol>
          </li>
        </ol>
      </section>
      <section>
        <h2>Subroutine: Scale element coordinates</h2>
        <p>
          The <dfn>scale element coordinates algorithm</dfn> takes {{double}} coordinates [|x|, |y|]
          and a {{CaptureController}} |controller|, and run the following steps:
        </p>
        <ol>
          <li>
            Let |scaleFactorX| be
            <code
              >(|x| /
              |controller|.{{CaptureController/[[CaptureWheelElement]]}}.{{Element/getBoundingClientRect()}}.{{DOMRect/width}})</code
            >.
          </li>
          <li>
            Let |scaleFactorX| be
            <code
              >(|x| /
              |controller|.{{CaptureController/[[CaptureWheelElement]]}}.{{Element/getBoundingClientRect()}}.{{DOMRect/height}})</code
            >.
          </li>
          <li>
            Let |surfaceWidth| be |controller|.<a data-cite="!screen-capture/#dfn-source"
              >[[\Source]]</a
            >'s viewport's width.
          </li>
          <li>
            Let |surfaceHeight| be |controller|.<a data-cite="!screen-capture/#dfn-source"
              >[[\Source]]</a
            >'s viewport's height.
          </li>
          <li>
            Let |scaledX| be
            <code>(|scaleFactorX| * |surfaceWidth|)</code>.
          </li>
          <li>
            Let |scaledY| be
            <code>(|scaleFactorY| * |surfaceHeight|)</code>.
          </li>
          <li>Return [|scaledX|, |scaledY|].</li>
        </ol>
        <div class="note">
          <p>This subroutine assumes that |controller| is [=actively capturing=].</p>
        </div>
      </section>
    </section>
    <section id="conformance"></section>
  </body>
</html>
